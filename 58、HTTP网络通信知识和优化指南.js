/*
从输入URL到看到页面“CRP关键节点的性能优化「HTTP网络层面」”
    @1 URL解析
    @2 缓存检查「强缓存 & 协商缓存304」
    @3 DNS解析
    @4 TCP的三次握手
    @5 HTTP传输「请求 & 响应」
    @6 TCP的四次挥手
    @7 渲染页面

@1 URL解析
    传输协议: HTTP / HTTPS (SSL) / FTP (文件上传) ...
    域名: 顶级、一级、二级...
    端口号: 0~65535 区分同一台服务器上的不同服务「HTTP: 80 HTTPS:443 FTP:21 默认端口号是浏览器处理的」
    问号参数: 可以把一些信息传递给服务器“GET系列”; 也可以实现两个页面之间的信息通信; SPA单页面中，实现组件和组件之间的通信; ...
    HASH哈希值: 锚点定位; HASH路由; ...
    ------
    编码问题: URL 中特殊内容的编码
        encodeURI decodeURI  编译能力弱，只是把URL地址中的中文或者空格等编译“用于整个URL的编译”
        encodeURIComponent decodeURIComponent 编译能力强，还可以多编译一些特殊符号用于“传递参数的每个值编译”
        escape unescape 只适合客户端之间的通信和编码
        axios.get(`http://www.xxx.com/api/list?name=${encodeURIComponent('珠峰')}&from=${encodeURIComponent('http://www.weixin.com/')}&lx=1`);

@2 缓存检查 -> 针对于静态资源文件 "例如: html/css/js/图片..."
    缓存位置: 内存、硬盘
    F5普通刷新「TAB页卡没关闭」: 内存->硬盘
    重新打开页面: 硬盘
    CTRL+F5强制刷新: 不检测任何缓存，直接向服务器发送请求

    @1强缓存
        + 先检测本地是否有强缓存，有、且没过期，直接本地获取，然后渲染「HTTP状态码: 200」
        + 如果没有或者过期了，则重新向服务器发送请求，拉取回最新的结果，渲染的同时，把本次结果缓存起来
        + ...
        优势: 性能优化的重要手段，可以保证第二次及以后再访问产品，速度会很快...
        弊端: 可能无法保证本地获取的资源是最新的...
            + HTML是不能做强缓存的
            + 只要HTML不处理强缓存，我们就可以保证其余资源的及时更新: 请求资源后面设置时间戳 或者 文件名字根内容生成HASH名...
        服务器设置的强缓存: 在每一次重新从服务器拉取最新资源文件的时候，都在响应头中携带 Cache-Control / Expires "缓存有效期"，客户端浏览器自动帮助我们把信息缓存起来，包含它的有效期...以后再访问这些资源，就可以看看本地是否有，以及是否过期了

    @2协商缓存304「只有强缓存失效后，才会校验协商缓存」
        + 如果啥缓存都没有，直接从服务器获取最新的资源信息 "把信息缓存起来；强缓存: 把Cache-Control/Expires存储起来；协商缓存: 把 Last-Modified/ETag存储起来..." Last-Modified: 当前资源文件在服务器端最后修改的时间   ETag: 每一次修改文件都会生成一个标志
        + 再次请求这个页面，强缓存不生效，则开始协商缓存
            + 向服务器发送请求，同时带上 if-Modifyed-Since: Last-Modified 或者 if-None-Match: ETag 传递给服务器；服务器根据传递的时间/标志，和服务器本身资源文件最后修改的时间/标志，进行对比，如果一样，说明文件没有更新过，直接返回304即可，无需返回内容；如果不一样，说明更新过，那么则返回最新的内容和最新的 Last-Modified/ETag...
            + 如果接收的是304，直接从本地缓存总获取信息渲染即可
            + 协商缓存总会发起请求
    ------
    HTML文件资源是可以使用协商缓存的

    @3数据缓存「AJAX/FETCH...」

@3 DNS解析「域名解析」
    在DNS服务器上，基于域名找到服务器的外网IP，后面我就可以基于服务器的外网IP找到服务器...
    www.baidu.com   220.181.38.149
    @1 百度页面有多个服务器 每一次DNS解析时间预计在 20~120 毫秒
        + 我们 应减少DNS请求次数
        + 可以 使用DNS预获取(DNS Prefetch)
    + 可以仿照 京东官网 用 link标签 代码从上往下执行 遇到 link标签 会自动开辟一个线程 去做DNS解析 获取到后会缓存在本地 遇到资源请求时从本地获取

    @2 服务器拆分
        优点:
            + 资源的合理利用
            + 抗压能力加强
            + 提高HTTP并发
            + ...
        Web服务器：静态资源的发布
        数据服务器：API数据接口、数据库
        图片/视频/音频服务器
        第三方插件服务器

@4 TCP三次握手
    在拿到外网IP后，我们开始建立客户端和服务器端连接的通道"TCP通道"
        TCP: 稳定的网络通信协议「图稳定」
        UDP: 不稳定的网络通信协议「图个快，例如音视频的传输」

@5 数据传输

@6 TCP四次挥手
    断开TCP连接通道

@7 渲染页面
*/

/*
性能优化汇总
1.利用缓存
    + 对于静态资源文件实现强缓存和协商缓存(扩展: 文件有更新，如何保证及时刷新? )
    + 对于不经常更新的接口数据采用本地存储做数据缓存(扩展: cookie / localStorage / vuex|redux 区别? )
2.DNS优化
    + 分服务器部署，增加HTTP并发性(导致DNS解析变慢)
    + DNS Prefetch
3.TCP的三次握手和四次挥手
    + Connection:keep-alive
4.数据传输
    + 减少数据传输的大小
        + 内容或者数据压缩(webpack等)
        + 服务器端一定要开启GZIP压缩(一般能压缩60%左右)
        + 大批量数据分批次请求(例如:下拉刷新或者分页，保证首次加载请求数据少)
    + 减少HTTP请求的次数
        + 资源文件合并处理
        + 字体图标
        + 雪碧图 CSS-Sprit
        + 图片的BASE64
5.CDN服务器“地域分布式”
6.采用HTTP2.0
======
网络优化是前端性能优化中的重点内容，因为大部分的消耗都发生在网络层，尤其是第一次页面加载，如何减少等待时间很重要“减少白屏的效果和时间”
    + LOADDING 人性化体验
    + 骨架屏: 客户端骨架屏 + 服务器骨架屏
    + 图片延迟加载
    + ...
*/

/*
HTTP1.0和HTTP1.1的一些区别
● 缓存处理：HTTP1.0中主要使用Last-Modified, Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略: ETag, Cache-Control...
● 带宽优化及网络连接的使用： HTTP1.1支持断点续传，即返回码是206 (Partial Content)
● 错误通知的管理： 在HTTP1.1中新增了24个错误状态响应码，如409 (Conflict) 表示请求的资源与资源的当前状态发生冲突; 410 (Gone) 表示服务器上的某个资源被永久性的删除...
● Host头处理：在HTTP1.0中认为每 台服务器都绑定一个唯一 的IP地址， 因此，请求消息中的URL并没有传递主机名(hostname) 。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机(Multi-homed Web Servers)，并且它们共享-个IP地址。 HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误 (400 Bad Request)
● 长连接：HTTP1.1中默认开启Connection: keep-alive, 一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点



HTTP2.0和HTTP1.X相比的新特性
● 新的二进制格式(Binary Format)：HTTP1.x的解析是基于文本， 基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多.二进制则不同，只认0和1的组合，基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮
● header压缩：HTTP1.x的header带有大量信息， 而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小
● 服务端推送(server push)：例如我的网页有-个sytle.css的请求， 在客户端收到sytle.css数据的同时， 服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了



通过在应用生成HTTP响应头信息中设置Link命令
Link: </styles.css>; rel=preload; as=style, </example.png>; rel=preload; as= image



HTTP/1.0每次请求响应， 建立个TCP连接，用完关闭
HTTP/1.1「长连接」 若干个请求排队串行化单线程处理， 后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞;
HTTP/2.0「多路复用」 多个请求可同时在一个连接 上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行;
*/